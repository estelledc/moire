---
created: 2026-02-26T02:29:05Z
modified: 2026-02-26T02:29:18Z
---

你们在应用中还使用了哪些其他技术？为什么选择它们？

除了前面提到的 AI/ML 技术（CoreML、SoundAnalysis、Vision、FoundationModels），Commute Focus 还使用了以下技术：

Swift 6 严格并发模型——整个项目采用 Swift 6 语言模式（swiftLanguageVersions: [.version("6")]），编译器强制执行完整的数据竞争安全检查。所有 ViewModel 和 Engine 都标注了 @MainActor。选择 Swift 6 是因为通勤场景下应用需要同时处理音频流、视频帧、计时器和用户触摸——任何数据竞争都可能导致崩溃或分数计算错误，编译器级别的并发安全比运行时调试可靠得多。

Combine 响应式数据流——ViewModel 层大量使用 Combine（Publishers.CombineLatest4、$property.sink、objectWillChange 转发）连接传感器数据和 UI。例如 SessionViewModel 用 CombineLatest4 同时监听噪音信号、置信度、音频可用性和降级状态四个流，合并后统一更新。选择 Combine 而非纯 async/await 是因为传感器数据是连续流——Combine 的 Publisher 模型天然适合"多个数据源实时合流"的场景。

AVFoundation 双管线——SoundSenseManager 使用 AVAudioEngine 实时采集麦克风音频，同时喂给 SoundAnalysis 分类器和自定义 RMS 分贝计算；VisionSenseManager 通过 AVCaptureSession 配置前置摄像头，每 0.4 秒采样一帧送入 Vision 框架。选择 0.4 秒采样间隔是精度与电池消耗的权衡。当 AVAudioEngine 不可用时自动降级为 AVAudioRecorder 计量模式。

Swift Charts + 纯 SwiftUI 自定义可视化——趋势页使用 Apple 原生 Swift Charts 渲染 7 天折线图；同时从零构建了三个自定义可视化组件（SWRadarChart 三轴雷达图、SWRingChart 环形进度图、SWActivityHeatmap 活动热力图），全部使用 SwiftUI 的 Path 和 Shape 协议手绘。选择手绘是因为 Swift Playground 不支持 SPM 外部依赖，且这些图表需要与自定义主题系统深度集成。

自定义主题系统——AppTheme 定义了 18 个语义化颜色属性的设计令牌系统，提供标准和色盲友好两套主题。所有 View 通过 theme 属性获取颜色。选择自建主题系统是因为需要在两套配色之间即时切换，且卡片颜色需要与训练刺激卡的视觉辨识度直接关联。

JSON 文件持久化 \+ UserDefaults——训练记录用 JSON 文件存储在 Documents 目录（原子写入策略：先写临时文件再 replaceItemAt），设置用 UserDefaults。选择 JSON 而非 CoreData/SwiftData 是因为数据结构简单（扁平的 SessionRecord 数组），不需要关系查询，且可调试性更好。

确定性伪随机序列（SplitMix64）——SessionEngine 实现了自定义的 SeededGenerator，用时间戳异或系统随机数作为种子。每次训练的卡片序列都是确定性的，种子保存在 SessionRecord 中。选择自建 PRNG 是因为需要可复现性——相同种子产生相同训练序列，对调试和未来的重放功能至关重要。

UIKit 触觉反馈——通过 UIImpactFeedbackGenerator 提供 0%-100% 连续可调的触觉强度。选择 UIKit API 而非 SwiftUI 的 sensoryFeedback 是因为需要精确控制 intensity 参数。

零第三方依赖——Package.swift 中没有任何外部 SPM 依赖。所有功能都从零构建或使用 Apple 原生框架。这既是 Swift Playground 格式的约束，也是有意的设计选择：零依赖意味着零供应链风险，编译快，包体小
