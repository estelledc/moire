---
created: 2026-02-19T14:57:40Z
modified: 2026-02-19T15:02:34Z
---

# Two Sum 学习笔记（从卡住到讲清楚）

## 1. 题目一句话重述

给定整数数组 `nums` 和目标值 `target`，找出两个下标 `i, j`，满足 `nums[i] \+ nums[j] == target`，返回这两个下标。

\---

## 2. 审题校准（我一开始最容易错的点）

\- 返回的是下标，不是数值。

\- 不能重复使用同一个元素，意思是同一下标不能用两次，不是值不能相同。

\- 示例 `nums=[3,3], target=6` 返回 `[0,1]` 是合法的，因为是两个不同位置。

\- `nums.length` 最多 `10^4`，`O(n^2)` 通常不推荐作为最终方案。

\---

## 3. 朴素解法（先保证正确）

思路：双重循环枚举两个不同下标 `i < j`，检查是否和为 `target`。

\- `Time`: `O(n^2)`

\- `Space`: `O(1)`

这一步的价值是：先拿到一个肯定正确的基线，再谈优化。

\---

## 4. 优化方向（瓶颈在哪里）

瓶颈是重复查找另一个数。

当遍历到 `x = nums[i]` 时，需要找的值是：

`need = target - x`

如果能在遍历过程中快速判断 `need` 是否出现过，就能把总复杂度降到线性。

\---

## 5. 最终方案核心（哈希表）

使用字典 `pos`，定义为：

`值 -> 下标`（`value -> index`）

遍历每个元素时：

1\. 先算 `need = target - x`

2\. 如果 `need` 在 `pos` 中，返回 `[pos[need], i]`

3\. 否则记录 `pos[x] = i`

关键顺序：先查后存，避免同一下标被使用两次。

\---

## 6. 正确性要点（面试可口述）

\- 若在第 `i` 轮发现 `need` 已在 `pos`，说明此前存在某个 `j < i`，满足 `nums[j] = need`。

\- 因为 `need + nums[i] = target`，所以返回 `[j, i]` 正确。

\- 先查后存保证 `j != i`，不会用同一个元素两次。

\- 题目保证唯一解，因此第一次命中即可返回。

\---

## 7. 复杂度结论

\- `Time`: `O(n)`（每个元素处理一次，查找/插入均摊 `O(1)`）

\- `Space`: `O(n)`（最坏情况下字典存下所有元素）

\---

## 8. 我踩过的坑

\- 把不能重复元素误解成值不能重复。

\- 用 `set` 只存值，最后拿不到下标。

\- 把字典方向写反（写成下标 -> 值）。

\- 把赋值写成比较（`=` 与 `==` 混用）。

\---

## 9. 一分钟面试话术模板

我会用哈希表记录值到下标的映射。遍历到当前值 `x` 时，先计算补数 `need = target - x`。如果 `need` 已出现，就直接返回之前下标和当前下标；如果没出现，就把当前值和下标放进哈希表。这样每个元素只处理一次，时间复杂度 `O(n)`，空间复杂度 `O(n)`。先查后存可以避免同一下标重复使用。

\---

## 10. 复盘清单（每次刷题后勾一遍）

\- [ ] 我能准确复述输入/输出和限制吗？

\- [ ] 我能先给出朴素正确解吗？

\- [ ] 我能明确说出瓶颈在哪里吗？

\- [ ] 我能讲清哈希表里键和值的含义吗？

\- [ ] 我能口述正确性和复杂度吗？
